package vagrant

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"

	"github.com/asheshgoplani/agent-deck/internal/session"
)

// SyncClaudeConfig synchronizes host-side Claude configuration files into the VM.
// Config files are synced with mcpServers stripped out — host MCPs reference local
// binaries that don't exist inside the VM. MCP configuration for the VM is handled
// separately by WriteMCPJson which generates a project-level .mcp.json.
//
// The method reads and syncs these config files:
// 1. Global config: CLAUDE_CONFIG_DIR/.claude.json (or ~/.claude/.claude.json)
// 2. User config: ~/.claude.json
// 3. Settings: ~/.claude/settings.json (statusLine, plugins, preferences)
// 4. Additional files referenced by settings (e.g. statusline.sh)
//
// All files are copied into the VM at their respective paths. If a file doesn't
// exist, it's silently skipped (not an error). Errors during sync are logged but
// don't fail the overall operation (non-fatal).
func (m *Manager) SyncClaudeConfig() error {
	// Use the injected function if available (for testing), otherwise use default
	writeFunc := m.writeFileToVMFunc
	if writeFunc == nil {
		writeFunc = m.writeFileToVM
	}

	// 1. Read and sync global config (without mcpServers)
	globalConfigDir := session.GetClaudeConfigDir()
	globalConfig := filepath.Join(globalConfigDir, ".claude.json")

	if data, err := os.ReadFile(globalConfig); err == nil {
		stripped := stripHostOnlyFields(data)
		if err := writeFunc("~/.claude/.claude.json", stripped); err != nil {
			// Non-fatal: continue even if sync fails
		}
	}

	homeDir, err := os.UserHomeDir()
	if err != nil {
		return nil
	}

	// 2. Read and sync user config (without host-only fields)
	userConfig := filepath.Join(homeDir, ".claude.json")
	if data, err := os.ReadFile(userConfig); err == nil {
		stripped := stripHostOnlyFields(data)
		if err := writeFunc("~/.claude.json", stripped); err != nil {
			// Non-fatal
		}
	}

	// 3. Sync settings.json (statusLine, preferences — without plugins/hooks)
	settingsFile := filepath.Join(homeDir, ".claude", "settings.json")
	if data, err := os.ReadFile(settingsFile); err == nil {
		stripped := stripSettingsForVM(data)
		if err := writeFunc("~/.claude/settings.json", stripped); err != nil {
			// Non-fatal
		}
	}

	// 4. Sync executable scripts referenced by settings (e.g. statusline).
	for _, relPath := range []string{
		".claude/statusline.sh",
	} {
		absPath := filepath.Join(homeDir, relPath)
		if data, err := os.ReadFile(absPath); err == nil {
			remotePath := "~/" + relPath
			if err := writeFunc(remotePath, data); err != nil {
				// Non-fatal
				continue
			}
			// Ensure scripts are executable inside the VM
			chmodCmd := m.vagrantCmd("ssh", "-c", fmt.Sprintf("chmod +x %s", remotePath))
			_ = chmodCmd.Run()
		}
	}

	return nil
}

// stripMCPServers removes the "mcpServers" key from a JSON config file.
// Host MCP definitions reference local binaries that don't exist inside the VM,
// so they must be stripped. MCP config for the VM comes from the project-level
// .mcp.json generated by WriteMCPJson instead.
// Returns the original data unchanged if parsing fails.
func stripMCPServers(data []byte) []byte {
	return stripJSONKeys(data, []string{"mcpServers"})
}

// stripHostOnlyFields removes keys from ~/.claude.json that are host-specific
// and cause errors inside the VM:
//   - mcpServers: references host-local binaries
//   - installMethod: host says "native" but VM uses npm global install,
//     causing Claude Code to look for ~/.local/bin/claude which doesn't exist
//   - oauthAccount: OAuth tokens live in the host's system keychain and can't
//     transfer; leaving this causes confusing "Not logged in" vs stale token errors
func stripHostOnlyFields(data []byte) []byte {
	return stripJSONKeys(data, []string{"mcpServers", "installMethod", "oauthAccount"})
}

// stripSettingsForVM removes keys from ~/.claude/settings.json that don't work
// inside the VM:
//   - enabledPlugins: plugin npm packages aren't installed in the VM, causing
//     mass install failures (e.g. "22 plugins failed to install")
//   - hooks: hook commands may reference host-side binaries or paths
func stripSettingsForVM(data []byte) []byte {
	return stripJSONKeys(data, []string{"enabledPlugins", "hooks"})
}

// stripJSONKeys removes the specified keys from a JSON object.
// Returns the original data unchanged if parsing fails or no keys are present.
func stripJSONKeys(data []byte, keys []string) []byte {
	var config map[string]json.RawMessage
	if err := json.Unmarshal(data, &config); err != nil {
		return data
	}
	changed := false
	for _, key := range keys {
		if _, has := config[key]; has {
			delete(config, key)
			changed = true
		}
	}
	if !changed {
		return data
	}
	stripped, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		return data
	}
	return stripped
}

// writeFileToVM writes a file to the VM using base64 encoding to avoid shell quoting issues.
// The file content is base64-encoded and passed via echo, then decoded and written to the
// remote path inside the VM via 'vagrant ssh -c'.
//
// This approach avoids all shell quoting complexity that would arise from trying to pass
// JSON content (with quotes, special characters, etc.) directly through the shell.
func (m *Manager) writeFileToVM(remotePath string, content []byte) error {
	// Encode content as base64 to avoid shell quoting issues
	encoded := base64.StdEncoding.EncodeToString(content)

	// Create the command:
	// 1. mkdir -p $(dirname REMOTE_PATH) - ensure parent directory exists
	// 2. echo 'BASE64' | base64 -d > REMOTE_PATH - decode and write file
	cmdStr := fmt.Sprintf("mkdir -p $(dirname %s) && echo '%s' | base64 -d > %s",
		remotePath, encoded, remotePath)

	cmd := m.vagrantCmd("ssh", "-c", cmdStr)
	return cmd.Run()
}

// createWriteFileCmd creates the exec.Cmd for writing a file to the VM.
// This is separated out to allow testing without actually executing vagrant commands.
func (m *Manager) createWriteFileCmd(remotePath string, content []byte) *exec.Cmd {
	encoded := base64.StdEncoding.EncodeToString(content)
	cmdStr := fmt.Sprintf("mkdir -p $(dirname %s) && echo '%s' | base64 -d > %s",
		remotePath, encoded, remotePath)
	return m.vagrantCmd("ssh", "-c", cmdStr)
}

// writeFileToVMFunc is an injectable function for testing.
// In tests, this can be set to capture calls without executing vagrant commands.
// In production, this is nil and writeFileToVM is used directly.
type writeFileToVMFuncType func(remotePath string, content []byte) error
